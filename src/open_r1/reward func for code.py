import re
from datasets import load_dataset
from dotenv import load_dotenv
from e2b_code_interpreter import Sandbox
load_dotenv()

# preparing the dataset
dataset = load_dataset("OpenCoder-LLM/opc-sft-stage2","educational_instruct",split="train[:10]")
def process_task(task):
    # Rename the column every_point to function_name
    task["function_name"] = task.pop("entry_point")
    
    # Remove "assert" from the beginning of each string in the testcase column
    task["testcase"] = [re.sub(r'^assert\s*', '', tc) for tc in task["testcase"]]
    
    # Keep only the instruction, function_name, and testcase columns
    return {
        "instruction": task["instruction"],
        "function_name": task["function_name"],
        "testcase": task["testcase"]
    }

# Apply the map function to the dataset
dataset = dataset.map(process_task)


# Constants for the reward function, coefficents decide the weightage of accuracy and time depending on your preference
SANDBOX_API_KEY = "YOUR_E2B_API_KEY" # or add E2B_API_KEY to your environment
ACCURACY_COEFF = 0.7
TIME_COEFF = 0.3
MAX_EXECUTION_TIME = 5.0  # seconds

def execute_in_sandbox(code):
    """Executes the given code in a sandbox and returns the result."""
    sbx = Sandbox(api_key=SANDBOX_API_KEY)
    execution = sbx.run_code(code)
    result = execution.logs.stdout[0]
    sbx.kill()
    return result

def extract_execution_time(result):
    """Extracts the execution time from the sandbox result."""
    execution_time_match = re.search(r"Execution Time: (\d+\.\d+)", result)
    if execution_time_match:
        return float(execution_time_match.group(1))
    else:
        return 0.0

def extract_solution_function(completion):
    """Extracts the solution function from the completion string."""
    solution_function_match = re.search(r'```python\n(.*?)\n```', completion, re.DOTALL)
    return solution_function_match.group(1) if solution_function_match else ""

def reward_solution(completion, test_cases):
    """Calculates the reward for the given code and test cases based on the count of test cases passed and execution time."""
    solution_function = extract_solution_function(completion)
    code = generate_code(solution_function, test_cases)
    result = execute_in_sandbox(code)
    passed = result.count("True")
    execution_time = extract_execution_time(result)
    
    reward = (ACCURACY_COEFF * (passed / len(test_cases)) +
              TIME_COEFF * (1 - execution_time / MAX_EXECUTION_TIME))
    return reward

def generate_code(solution_function, test_cases):
    """Generates the code string to be executed in the sandbox."""
    test_cases_code = "\n".join(f"print({test_case})" for test_case in test_cases)
    code = f"""
import time
start_time = time.time()
{solution_function}
{test_cases_code}
end_time = time.time()
print("Execution Time:", end_time - start_time)
    """
    return code

def reward_func(completions, test_cases, **kwargs):
    """Reward function for GRPO Trainer"""
    return [reward_solution(completion, test_case) for completion, test_case in zip(completions, test_cases)]

# Example usage
prompt = "solve the coding task"

# Example completion generated by the model, this completion was generated by gpt-4o
completion = """
here's how you can solve the task:
```python
import re

def is_palindrome(s):
    # Use regex to remove non-alphanumeric characters and convert to lower case
    cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    # Check if the cleaned string is the same forwards and backwards
    return cleaned == cleaned[::-1]
```
"""
# Example test cases, taken from the first row of the dataset
test_case = [ "is_palindrome(\"No lemon, no melon\") == True", "is_palindrome(\"A man a plan a canal Panama\") == True", "is_palindrome(\"hello\") == False", "is_palindrome(\"racecar\") == True" ]

# converting them into a list of strings to represent the output from the training loop 
prompts = [prompt] * 5
completions = [completion] * 5
test_cases = [test_case] * 5


rewards = reward_func(completions, test_cases)
print("rewards:", rewards)